#ifndef CTRE__SIMPLE__HPP
#define CTRE__SIMPLE__HPP

// THIS FILE WAS GENERATED BY DESATOMAT TOOL, DO NOT MODIFY THIS FILE

namespace ctre {

struct simple {

// NONTERMINALS:
	struct escape {};
	struct mod {};
	struct opt2 {};
	struct opt {};
	struct s {}; using _start = s;
	struct seq2 {};
	struct seq {};

// 'action' types:
	struct alpha: ctll::action {};
	struct alt: ctll::action {};
	struct character: ctll::action {};
	struct digit: ctll::action {};
	struct optional: ctll::action {};
	struct plus: ctll::action {};
	struct sequence: ctll::action {};
	struct space: ctll::action {};
	struct star: ctll::action {};
	
	template <typename Move> struct rule {
		rule(...) { }
		using move = Move;
	};

// (q)LL1 function:
	using _others = ctll::neg_set<'(',')','*','+','?','\\','|'>;
	rule(s, ctll::epsilon) -> rule<ctll::epsilon>;
	rule(s, _others) -> rule<ctll::push<ctll::anything, character, mod, seq2, opt2>>;
	rule(s, ctll::term<'\\'>) -> rule<ctll::push< ctll::anything, escape, mod, seq2, opt2 >>;
	rule(s, ctll::term<'('>) -> rule<ctll::push<ctll::term<'('>, opt, ctll::term<')'>, mod, seq2, opt2>>;
	rule(s, ctll::set<')','*','+','?','|'>) -> rule<ctll::reject>;

	rule(escape, ctll::term<'a'>) -> rule<ctll::push<ctll::anything, alpha>>;
	rule(escape, ctll::term<'d'>) -> rule<ctll::push<ctll::anything, digit>>;
	rule(escape, ctll::term<'s'>) -> rule<ctll::push<ctll::anything, space>>;
	
	rule(mod, ctll::set<'(',')','\\','|'>) -> rule<ctll::epsilon>;
	rule(mod, ctll::epsilon) -> rule<ctll::epsilon>;
	rule(mod, _others) -> rule<ctll::epsilon>;
	rule(mod, ctll::term<'?'>) -> rule<ctll::push<ctll::anything, optional>>;
	rule(mod, ctll::term<'+'>) -> rule<ctll::push<ctll::anything, plus>>;
	rule(mod, ctll::term<'*'>) -> rule<ctll::push<ctll::anything, star>>;

	rule(opt2, ctll::term<')'>) -> rule<ctll::epsilon>;
	rule(opt2, ctll::epsilon) -> rule<ctll::epsilon>;
	rule(opt2, ctll::term<'|'>) -> rule<ctll::push<ctll::anything, seq, alt, opt2>>;

	rule(opt, _others) -> rule<ctll::push<ctll::anything, character, mod, seq2, opt2>>;
	rule(opt, ctll::term<'\\'>) -> rule<ctll::push<ctll::anything, escape, mod, seq2, opt2>>;
	rule(opt, ctll::term<'('>) -> rule<ctll::push<ctll::anything, opt, ctll::term<')'>, mod, seq2, opt2>>;
	rule(opt, ctll::set<')','*','+','?','|'>) -> rule<ctll::reject>;

	rule(seq2, ctll::set<')','|'>) -> rule<ctll::epsilon>;
	rule(seq2, ctll::epsilon) -> rule<ctll::epsilon>;
	rule(seq2, _others) -> rule<ctll::push<ctll::anything, character, sequence, mod, seq2>>;
	rule(seq2, ctll::term<'\\'>) -> rule<ctll::push<ctll::anything, escape, sequence, mod, seq2>>;
	rule(seq2, ctll::term<'('>) -> rule<ctll::push<ctll::anything, opt, ctll::term<')'>, sequence, mod, seq2>>;
	rule(seq2, ctll::set<'*','+','?'>) -> rule<ctll::reject>;

	rule(seq, _others) -> rule<ctll::push<ctll::anything, character, mod, seq2>>;
	rule(seq, ctll::term<'\\'>) -> rule<ctll::push<ctll::anything, escape, mod, seq2>>;
	rule(seq, ctll::term<'('>) -> rule<ctll::push<ctll::anything, opt, ctll::term<')'>, mod, seq2>>;
	rule(seq, ctll::set<')','*','+','?','|'>) -> rule<ctll::reject>;
	
	// term on stack and on input means pop_input;
	template <auto A> rule(ctll::term<A>, ctll::term<A>) -> rule<ctll::pop_input>;
	
	// if the type on stack (range, set, neg_set, anything) is constructible from the terminal => pop_input
	template <typename Expected, auto V> rule(Expected, ctll::term<V>) -> rule<std::enable_if_t<std::is_constructible_v<Expected, ctll::term<V>>, ctll::pop_input>>;
	
	// empty stack and empty input means we are accepting 
	rule(ctll::empty_stack_symbol, ctll::epsilon) -> rule<ctll::accept>;
	
	// not matching anything else => reject
	rule(...) -> rule<ctll::reject>;

};

}

#endif //CTRE__SIMPLE__HPP
